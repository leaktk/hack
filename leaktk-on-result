#!/usr/bin/env python3

import json
import logging
import os
import re
import shlex
import subprocess
import sys

from argparse import ArgumentParser
from typing import Dict, Any, List, Union

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
)

logger = logging.getLogger("leaktk-on-result")


def get_nested_value(data: Dict[str, Any], path: str) -> Union[str, None]:
    """
    Access a nested value in a dictionary using dot notation.
    For example, "location.path" would access data["location"]["path"]

    Returns None if any part of the path doesn't exist.
    """
    # with archive support, paths may contain a ! to indicate there's an inner
    # path. This deals with that for backwards compatibility
    remove_inner_path = False
    if path == "location.path":
        remove_inner_path = True

    parts = path.split(".")
    current: Any = data

    for part in parts:
        if isinstance(current, dict) and part in current:
            current = current[part]
        else:
            return None

    if current is None:
        return current

    current = str(current)
    if remove_inner_path:
        return current.split("!", 1)[0]

    return current


def replace_template_vars(command: str, data: Dict[str, Any]) -> str:
    """
    Replace template variables in the format {{path.to.field}} with values from data.
    """

    def replace_match(match):
        var_path = match.group(1).strip()
        value = get_nested_value(data, var_path)
        return value if value is not None else match.group(0)

    pattern = r"\{\{\s*([^{}]+)\s*\}\}"
    return re.sub(pattern, replace_match, command)


def process_result(workdir: str, cmdargs: List[str], result: Dict[str, Any]) -> bool:
    """
    Process a single result by replacing template vars in command and executing it.
    Returns True if successful, False otherwise.
    """
    processed_args = [replace_template_vars(arg, result) for arg in cmdargs]

    logger.debug(f"Running command: {shlex.join(processed_args)}")

    try:
        # Execute the command in the working directory
        process = subprocess.run(
            processed_args,
            cwd=workdir,
            capture_output=True,
            text=True,
            check=False,  # Don't raise exception, we'll handle errors
        )

        if process.returncode != 0:
            logger.error(f"Command failed with exit code {process.returncode}")
            logger.error(f"Error output: {process.stderr}")
            return False

        logger.debug(f"Command output: {process.stdout}")
        return True
    except Exception as e:
        logger.error(f"Error executing command: {e}")
        return False


def parse_args(args):
    parser = ArgumentParser(
        prog="leaktk-on-result", description="Run a command on each leaktk result"
    )
    parser.add_argument(
        "--log-level",
        choices=("NOTSET", "DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"),
        default="INFO",
    )
    parser.add_argument("workdir")
    parser.add_argument("cmdargs", nargs="*")
    return parser.parse_args(args)


def main():
    args = parse_args(sys.argv[1:])

    if not os.path.isdir(args.workdir):
        logger.error(f"The working directory doesn't exist: {args.workdir}")
        sys.exit(1)

    logger.setLevel(getattr(logging, args.log_level))

    success = True
    scan_data = ""

    # Read JSON data from stdin
    for line in sys.stdin:
        try:
            data = json.loads(line)
            # Find the results array
            if "results" in data and isinstance(data["results"], list):
                results = data["results"]
                logger.info(f"Processing {len(results)} results...")

                for i, result in enumerate(results):
                    logger.debug(f"Processing result {i+1}/{len(results)}")
                    if not process_result(args.workdir, args.cmdargs, result):
                        success = False

                if success:
                    logger.info(f"Results processed successfully!")
            else:
                logger.error("No results array found in input data")
                success = False
        except json.JSONDecodeError as e:
            logger.error(f"Failed to parse JSON: {e}")
            success = False

    sys.exit(0 if success else 1)


if __name__ == "__main__":
    main()
